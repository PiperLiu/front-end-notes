# VUE3 + ts 的（知乎）者也

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [项目资源](#项目资源)
- [项目初始化](#项目初始化)
  - [安装bootstrap](#安装bootstrap)

<!-- /code_chunk_output -->

### 项目资源
* **项目演示站点：[http://zhihu.vikingship.xyz/](http://zhihu.vikingship.xyz/)**
* 在线后端API 查询和使用站点：[http://api.vikingship.xyz/](http://api.vikingship.xyz/)
* 项目在线文档：[http://docs.vikingship.xyz/](http://docs.vikingship.xyz/)
* 完成的组件库展示：[http://showcase.vikingship.xyz/](http://showcase.vikingship.xyz/)
* 流程图和原型图
* 购买后直接可以接入使用的真实后端API
* **如果您想学习本课程，请支持正版，谢谢！ [https://coding.imooc.com/class/449.html](https://coding.imooc.com/class/449.html)**

### 项目初始化

版本：
```bash
$node --version
v14.17.0
$vue --version
@vue/cli 4.5.12
```

创建：
```bash
$vue create zheye

? Please pick a preset: Manually select features
? Check the features needed for your project: Choose Vue version, Babel, TS, Linter
? Choose a version of Vue.js that you want to start the project with 3.x (Preview)
? Use class-style component syntax? No
? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? No
? Pick a linter / formatter config: Standard
? Pick additional lint features: Lint on save
? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files
? Save this as a preset for future projects? No
```

#### 安装bootstrap

```bash
$npm install bootstrap@next --save
```

### 想要给构造函数Array断言类型（使用vue的PropType）

```ts
import { defineComponent, PropType } from 'vue'

export interface ColumnProps {
  id: number;
  title: string;
  avatar: string;
  descrption: string;
}

export default defineComponent({
  name: 'ColumnList',
  props: {
    list: {
      type: Array as ColumnProps[],  // 不行，Array是构造函数
      type: Array as PropType<ColumnProps[]>,  // 这个
      requried: true
    }
  }
})
```

### 让vetur自动补全<template>
在 `settings.json` 中：
```
"vetur.experimental.templateInterpolationService": true
```

#### parser: "vue-eslint-parser"
此外，加入 `parser: "vue-eslint-parser"` 在 `.eslintrc.js` 中。

否者会报一些很低级的语法错误（实际上没有错误）。

### 渐进式设计dropdown

第一个版本的 `dropdown` ：
```html
<template>
<div class="dropdown">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <li class="dropdown-item">
      <a href="#">新建文章</a>
    </li>
    <li class="dropdown-item">
      <a href="#">编辑资料</a>
    </li>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    return {
      isOpen,
      toggleOpen
    }
  }
})
</script>
```

问题：
- 点击其他区域，菜单栏不自动取消
- 点击文章后，除了跳转，没法添加其他行为

**没有关系，我们先实现基础的，之后再改进。**

#### 保证 html 语义化

方案一：
```html
const dropdownItems = [
  {'text': 'option one'},
  {'text': 'option two'}
]
<dropdown :title="" :items="dropdownItems" />
```

方案二：
```html
<dropdown :title="">
  <dropdown-item>
    option one
  </dropdown-item>
  <dropdown-item>
    option two
  </dropdown-item>
</dropdown>
```

如上，更推荐使用方案二，因为方案二更加语义化。

所以新建组件 `dropdown-item` ：
```html
<template>
  <li
    class="dropdown-option"
    :class="{'is-disabled': disabled}"
  >
    <slot></slot>
  </li>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  props: {
    disabled: {
      type: Boolean,
      default: false
    }
  }
})
</script>

<style>
.dropdown-option.is-disabled * {
  color: #6c757d;
  pointer-events: none;
  background-color: transparent;
}
</style>
```

第二个版本的 `dropdown` ：
```html
<template>
<div class="dropdown">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <slot></slot>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    return {
      isOpen,
      toggleOpen
    }
  }
})
</script>
```

#### 点击外部元素表单关闭
要完成的任务：
- 在 `mounted` 时添加 `click` 事件，在 `unmounted` 的时候将事件删除
- 拿到 `Dropdown` 的 DOM 元素从而判断，点击的内容是否被这个元素包含

在 `const dropdownRef = ref<null | HTMLElement>(null)` 后，在 `setup` 中返回出去，在模板中 `ref="dropdownRef"`，则 vue 自动把 `dropdownRef` 绑定到 DOM 上。

第三个版本的 `dropdown` ：
```html
<template>
<div class="dropdown" ref="dropdownRef">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <slot></slot>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onUnmounted } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const dropdownRef = ref<null | HTMLElement>(null)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    const handler = (e: MouseEvent) => {
      if (dropdownRef.value) {
        if (!dropdownRef.value.contains(e.target as HTMLElement) && isOpen.value) {
          isOpen.value = false
        }
      }
    }
    onMounted(() => {
      document.addEventListener('click', handler)
    })
    onUnmounted(() => {
      document.removeEventListener('click', handler)
    })
    return {
      isOpen,
      toggleOpen,
      dropdownRef
    }
  }
})
</script>
```

如上，我们其实没有用到元素本身的特性。我们可以把逻辑抽取出来。

#### 抽取逻辑到hooks
在 `scr/hook` 中新建 `useClickOutside.ts` ：
```ts
import { ref, onMounted, onUnmounted, Ref } from 'vue'

const useClickOutside = (elementRef: Ref<null | HTMLElement>) => {
  const isClickOutside = ref(false)
  const handler = (e: MouseEvent) => {
    if (elementRef.value) {
      if (elementRef.value?.contains(e.target as HTMLElement)) {
        isClickOutside.value = false
      } else {
        isClickOutside.value = true
      }
    }
  }
  onMounted(() => {
    document.addEventListener('click', handler)
  })
  onUnmounted(() => {
    document.removeEventListener('click', handler)
  })
  return isClickOutside
}

export default useClickOutside
```

于是第四个版本的 `dropdown` ：
```html
<template>
<div class="dropdown" ref="dropdownRef">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <slot></slot>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref, watch } from 'vue'
import useClickOutside from '../hooks/useClickOutside'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const dropdownRef = ref<null | HTMLElement>(null)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }

    const isClickOutside = useClickOutside(dropdownRef)
    watch(isClickOutside, () => {
      if (isOpen.value && isClickOutside.value) {
        isOpen.value = false
      }
    })
    return {
      isOpen,
      toggleOpen,
      dropdownRef
    }
  }
})
</script>
```
