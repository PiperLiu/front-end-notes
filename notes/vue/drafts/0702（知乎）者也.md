# VUE3 + ts 的（知乎）者也

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [项目资源](#项目资源)
- [项目初始化](#项目初始化)
  - [安装bootstrap](#安装bootstrap)
- [想要给构造函数Array断言类型（使用vue的PropType）](#想要给构造函数array断言类型使用vue的proptype)
- [让vetur自动补全<template>](#让vetur自动补全template)
  - [parser: "vue-eslint-parser"](#parser-vue-eslint-parser)
- [渐进式设计dropdown](#渐进式设计dropdown)
  - [保证 html 语义化](#保证-html-语义化)
  - [点击外部元素表单关闭](#点击外部元素表单关闭)
  - [抽取逻辑到hooks](#抽取逻辑到hooks)
- [设计validate-input](#设计validate-input)
  - [vue3的v-model是一个breaking change](#vue3的v-model是一个breaking-change)
  - [使用 $attrs 支持默认属性](#使用-attrs-支持默认属性)

<!-- /code_chunk_output -->

### 项目资源
* **项目演示站点：[http://zhihu.vikingship.xyz/](http://zhihu.vikingship.xyz/)**
* 在线后端API 查询和使用站点：[http://api.vikingship.xyz/](http://api.vikingship.xyz/)
* 项目在线文档：[http://docs.vikingship.xyz/](http://docs.vikingship.xyz/)
* 完成的组件库展示：[http://showcase.vikingship.xyz/](http://showcase.vikingship.xyz/)
* 流程图和原型图
* 购买后直接可以接入使用的真实后端API
* **如果您想学习本课程，请支持正版，谢谢！ [https://coding.imooc.com/class/449.html](https://coding.imooc.com/class/449.html)**

### 项目初始化

版本：
```bash
$node --version
v14.17.0
$vue --version
@vue/cli 4.5.12
```

创建：
```bash
$vue create zheye

? Please pick a preset: Manually select features
? Check the features needed for your project: Choose Vue version, Babel, TS, Linter
? Choose a version of Vue.js that you want to start the project with 3.x (Preview)
? Use class-style component syntax? No
? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? No
? Pick a linter / formatter config: Standard
? Pick additional lint features: Lint on save
? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files
? Save this as a preset for future projects? No
```

#### 安装bootstrap

```bash
$npm install bootstrap@next --save
```

### 想要给构造函数Array断言类型（使用vue的PropType）

```ts
import { defineComponent, PropType } from 'vue'

export interface ColumnProps {
  id: number;
  title: string;
  avatar: string;
  descrption: string;
}

export default defineComponent({
  name: 'ColumnList',
  props: {
    list: {
      type: Array as ColumnProps[],  // 不行，Array是构造函数
      type: Array as PropType<ColumnProps[]>,  // 这个
      requried: true
    }
  }
})
```

### 让vetur自动补全<template>
在 `settings.json` 中：
```
"vetur.experimental.templateInterpolationService": true
```

#### parser: "vue-eslint-parser"
此外，加入 `parser: "vue-eslint-parser"` 在 `.eslintrc.js` 中。

否者会报一些很低级的语法错误（实际上没有错误）。

### 渐进式设计dropdown

第一个版本的 `dropdown` ：
```html
<template>
<div class="dropdown">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <li class="dropdown-item">
      <a href="#">新建文章</a>
    </li>
    <li class="dropdown-item">
      <a href="#">编辑资料</a>
    </li>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    return {
      isOpen,
      toggleOpen
    }
  }
})
</script>
```

问题：
- 点击其他区域，菜单栏不自动取消
- 点击文章后，除了跳转，没法添加其他行为

**没有关系，我们先实现基础的，之后再改进。**

#### 保证 html 语义化

方案一：
```html
const dropdownItems = [
  {'text': 'option one'},
  {'text': 'option two'}
]
<dropdown :title="" :items="dropdownItems" />
```

方案二：
```html
<dropdown :title="">
  <dropdown-item>
    option one
  </dropdown-item>
  <dropdown-item>
    option two
  </dropdown-item>
</dropdown>
```

如上，更推荐使用方案二，因为方案二更加语义化。

所以新建组件 `dropdown-item` ：
```html
<template>
  <li
    class="dropdown-option"
    :class="{'is-disabled': disabled}"
  >
    <slot></slot>
  </li>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({
  props: {
    disabled: {
      type: Boolean,
      default: false
    }
  }
})
</script>

<style>
.dropdown-option.is-disabled * {
  color: #6c757d;
  pointer-events: none;
  background-color: transparent;
}
</style>
```

第二个版本的 `dropdown` ：
```html
<template>
<div class="dropdown">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <slot></slot>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    return {
      isOpen,
      toggleOpen
    }
  }
})
</script>
```

#### 点击外部元素表单关闭
要完成的任务：
- 在 `mounted` 时添加 `click` 事件，在 `unmounted` 的时候将事件删除
- 拿到 `Dropdown` 的 DOM 元素从而判断，点击的内容是否被这个元素包含

在 `const dropdownRef = ref<null | HTMLElement>(null)` 后，在 `setup` 中返回出去，在模板中 `ref="dropdownRef"`，则 vue 自动把 `dropdownRef` 绑定到 DOM 上。

第三个版本的 `dropdown` ：
```html
<template>
<div class="dropdown" ref="dropdownRef">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <slot></slot>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onUnmounted } from 'vue'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const dropdownRef = ref<null | HTMLElement>(null)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }
    const handler = (e: MouseEvent) => {
      if (dropdownRef.value) {
        if (!dropdownRef.value.contains(e.target as HTMLElement) && isOpen.value) {
          isOpen.value = false
        }
      }
    }
    onMounted(() => {
      document.addEventListener('click', handler)
    })
    onUnmounted(() => {
      document.removeEventListener('click', handler)
    })
    return {
      isOpen,
      toggleOpen,
      dropdownRef
    }
  }
})
</script>
```

如上，我们其实没有用到元素本身的特性。我们可以把逻辑抽取出来。

#### 抽取逻辑到hooks
在 `scr/hook` 中新建 `useClickOutside.ts` ：
```ts
import { ref, onMounted, onUnmounted, Ref } from 'vue'

const useClickOutside = (elementRef: Ref<null | HTMLElement>) => {
  const isClickOutside = ref(false)
  const handler = (e: MouseEvent) => {
    if (elementRef.value) {
      if (elementRef.value?.contains(e.target as HTMLElement)) {
        isClickOutside.value = false
      } else {
        isClickOutside.value = true
      }
    }
  }
  onMounted(() => {
    document.addEventListener('click', handler)
  })
  onUnmounted(() => {
    document.removeEventListener('click', handler)
  })
  return isClickOutside
}

export default useClickOutside
```

于是第四个版本的 `dropdown` ：
```html
<template>
<div class="dropdown" ref="dropdownRef">
  <a href="#" class="btn btn-outline-light my-2 dropdown-toggle" @click.prevent="toggleOpen">
    {{title}}
  </a>
  <ul class="dropdown-menu" :style="{display: 'block'}" v-if="isOpen">
    <slot></slot>
  </ul>
</div>
</template>

<script lang="ts">
import { defineComponent, ref, watch } from 'vue'
import useClickOutside from '../hooks/useClickOutside'
export default defineComponent({
  name: 'Dropdown',
  props: {
    title: {
      type: String,
      required: true
    }
  },
  setup () {
    const isOpen = ref(false)
    const dropdownRef = ref<null | HTMLElement>(null)
    const toggleOpen = () => {
      isOpen.value = !isOpen.value
    }

    const isClickOutside = useClickOutside(dropdownRef)
    watch(isClickOutside, () => {
      if (isOpen.value && isClickOutside.value) {
        isOpen.value = false
      }
    })
    return {
      isOpen,
      toggleOpen,
      dropdownRef
    }
  }
})
</script>
```

### 设计validate-input

```ts
<validate-input :rules="" />

interface RuleProp {
  type: 'required' | 'email' | 'range' | ... ;
  message: string;
}

export type RulesProp = RuleProp[]
```

如上，我们可以设计一个可扩展的、可选类型的验证输入。

#### vue3的v-model是一个breaking change

https://v3.vuejs.org/guide/migration/v-model.html#migration-strategy

#### 使用 $attrs 支持默认属性

参考[./0204Non-Props属性.md](./0204Non-Props属性.md)。

### 表单中的父子组件通讯（mitt）

用`mitt`取代被废弃的`this.$on`。
```bash
npm install --save mitt
```

希望父组件 `ValidateForm` 有 `@click="submitForm"` ，此时希望自动验证子组件 `ValidateForm` 中的规则，对子组件中的数据校验。

逻辑是这样的：
- 父组件中创建监听实例 `export const emitter = mitt()` ，并且在 `onMounted` 时就监听 `form-item-created` 事件，将监听得到的对象传给函数 `callback(监听得到的对象)` 并执行： `emitter.on('form-item-created', callback)`
- `callback` 中，把传进来的对象（或者说验证函数）保存在 `funcArr: ValidateFunc[]` 里面，等待提交表单时逐个验证
- 父组件中，如果点击提交 `@click.prevent="submitForm"` ，在 `submitForm` 中，进行表单验证，就是把 `funcArr` 里面保存的验证函数都运行一遍；此外，还将触发自己的父组件事件 `form-submit` ，并将验证结果传递： `context.emit('form-submit', result)` ，以实现其他逻辑
- 子组件中引入监听实例，并且 `import { emitter } from './ValidateForm.vue'` ，将对象（是一个函数）传递给事件 `form-item-created` ： `emitter.emit('form-item-created', validateInput)`
- 而这个 `validateInput` 实际上并非一个纯逻辑，其带有自己的数据的，注意到函数的定义中有 `props.rules` ，实际上，不同的子组件 `ValidateInput.vue` 带有的 `props.rules` 是不同的，因此 `validateInput` 对于每个组件实例是不同的

ValidateForm.vue
```ts
import { defineComponent, onUnmounted } from 'vue'
import mitt from 'mitt'
type ValidateFunc = () => boolean
export const emitter = mitt()
export default defineComponent({
  emits: ['form-submit'],
  setup (props, context) {
    let funcArr: ValidateFunc[] = []
    const submitForm = () => {
      const result = funcArr.map(func => func()).every(result => result)
      context.emit('form-submit', result)
    }
    const callback = (func?: ValidateFunc) => {
      if (func) {
        funcArr.push(func)
      }
    }
    emitter.on('form-item-created', callback)
    onUnmounted(() => {
      emitter.off('form-item-created', callback)
      funcArr = []
    })
    return {
      submitForm
    }
  }
})
```

ValidateInput.vue
```ts
import { emitter } from './ValidateForm.vue'
...
export default defineComponent({
  props: {
    rules: Array as PropType<RulesProp> ...
  },
  setup (props, context) {
    ...
    const validateInput = () => {
      if (props.rules) {
        const allPassed = props.rules.every(rule => {
          ...
          return passed
        })
        inputRef.error = !allPassed
      }
    }

    onMounted(() => {
      emitter.emit('form-item-created', validateInput)
    })

    return {
      validateInput,
      ...
    }
  }
})
```

App.vue
```html
<template>
  <validate-form @form-submit="onFormSubmit">
      <validate-input></validate-input>
      <validate-input></validate-input>
  </validate-form>
</template>

<script lang="ts">
...
export default defineComponent({
  name: 'App',
  components: {
    ValidateInput,
    ValidateForm
  },
  setup () {
    ...

    const onFormSubmit = () => {
      console.log(emailVal.value)
      console.log(passwordVal.value)
    }

    return {
      onFormSubmit,
      ...
    }
  }
})
</script>
```

#### 不要忘了在onUnmounted时off掉响应

别忘了，我们要在 `onUnmounted()` 阶段清理掉响应。

```ts
setup(props, context) {
  emitter.on('form-item-created', callback)
  onUnmounted(() => {
    emitter.off('form-item-created', callback)
  })
}
```

#### 把every替换成map防止验证提前退出

```ts
const result = funcArr.every(func => func())
// 如果有一个 func() 返回 false ，之后的逻辑就不执行
// 因此改为 map ，因为这样才与产品需求相符合
const result = funcArr.map(func => func()).every(result => result)
```
